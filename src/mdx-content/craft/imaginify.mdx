---
title: 'Imaginify: AI-Powered Image Studio'
publishedAt: '2024-05-24'
summary: 'A Next.js SaaS platform combining Cloudinary AI transformations with Clerk auth and Stripe payments‚Äîdemocratizing professional image editing.'
category: 'Lab / Open Source'
githubURL: 'https://github.com/salahbm/imaginify-ai-sass'
image: '/medias/mdx-content/imaginify.png'
---

# Imaginify: AI Image Studio

**Imaginify** is a Next.js 14 SaaS that puts professional-grade AI image editing in everyone's hands. By orchestrating Clerk authentication, Cloudinary AI, Stripe payments, and MongoDB, it delivers a complete product experience‚Äînot just a tech demo.

## The Opportunity

AI-powered image editing used to require expensive software licenses or deep machine learning expertise. Imaginify proves you can build a competitive SaaS by composing best-in-class services, letting you focus on product experience instead of infrastructure.

## What It Does

üé® **AI-Powered Transformations**

- **Restore** ‚Äì Enhance and repair damaged or low-quality images
- **Remove Background** ‚Äì Intelligent subject isolation with one click
- **Generative Fill** ‚Äì Expand images beyond their original boundaries
- **Object Remove** ‚Äì Erase unwanted elements seamlessly
- **Recolor** ‚Äì Change object colors with AI-guided precision

üí≥ **Credit-Based Economy**

- Usage-based pricing powered by Stripe Checkout
- Transparent credit consumption per transformation
- Secure payment processing with webhook integration
- Real-time balance updates

üîê **Enterprise-Ready Auth**

- Clerk handles authentication and user management
- Automatic profile sync via webhooks
- Session management and protected routes
- Social login support

## Technical Architecture

### The Modern SaaS Stack

- **Next.js 14 App Router** ‚Äì Server actions replace traditional API routes
- **Clerk** ‚Äì Authentication, user management, and session handling
- **Cloudinary** ‚Äì AI transformations and media intelligence
- **MongoDB + Prisma** ‚Äì Data persistence with type-safe queries
- **Stripe** ‚Äì Payment processing and subscription management
- **Zod** ‚Äì Runtime validation for forms and API responses

### How It Works

**Authentication Flow**  
The <InlineCode>authMiddleware</InlineCode> makes every route private except landing pages and webhooks. Unauthenticated visitors are redirected to Clerk's hosted screens. When users sign up, a Clerk webhook mirrors their profile to MongoDB and stores the database ID in Clerk's public metadata for fast lookups.

**Transformation Pipeline**  
Users upload images via Cloudinary's widget, select a transformation type, and configure parameters through a debounced form. When they hit transform, the app:

1. Consumes credits from their balance
2. Generates a signed Cloudinary URL with AI transformation parameters
3. Persists the result to MongoDB with metadata
4. Displays the before/after comparison

**Billing Integration**  
Stripe Checkout sessions embed credit package metadata. When payment succeeds, the webhook creates a <InlineCode>Transaction</InlineCode> document and updates the user's credit balance atomically.

<Callout icon='üí°'>
  Everything funnels through typed server actions‚Äîyou get optimistic UI updates
  without hand-rolling API routes for every mutation.
</Callout>

## Code Highlights

### Transformation Workflow

The core transformation logic debounces form updates, merges Cloudinary configs, and persists results:

```tsx
// components/shared/TransformationForm.tsx
const onTransformHandler = async () => {
  setIsTransforming(true)

  setTransformationConfig(
    deepMergeObjects(newTransformation, transformationConfig)
  )

  setNewTransformation(null)

  startTransition(async () => {
    await updateCredits(userId, creditFee)
  })
}
```

Once the config settles, we generate a signed Cloudinary URL and persist the transformation:

```tsx
const imageData = {
  title: values.title,
  publicId: image?.publicId,
  transformationType: type,
  width: image?.width,
  height: image?.height,
  config: transformationConfig,
  secureURL: image?.secureURL,
  transformationURL: transformationUrl,
  aspectRatio: values.aspectRatio,
  prompt: values.prompt,
  color: values.color,
}
```

### Database Connection Singleton

Mongoose connections are cached in the serverless environment:

```ts
// lib/database/mongoose.ts
let cached = global.mongoose || { conn: null, promise: null }

export const connectToDatabase = async () => {
  if (cached.conn) return cached.conn

  if (!cached.promise) {
    cached.promise = mongoose.connect(MONGODB_URL, {
      dbName: 'imaginify',
      bufferCommands: false,
    })
  }

  cached.conn = await cached.promise
  return cached.conn
}
```

## Demo

<Image
  src='/medias/mdx-content/imaginify.png'
  alt='Imaginify AI transformation dashboard'
/>

## Impact & Learnings

**What This Project Demonstrates:**

‚úÖ **Service orchestration beats custom ML** ‚Äì Cloudinary's AI is production-ready out of the box  
‚úÖ **Server actions simplify SaaS** ‚Äì No API layer needed for most mutations  
‚úÖ **Webhooks enable real-time sync** ‚Äì Clerk and Stripe events keep data consistent  
‚úÖ **Credit systems work** ‚Äì Usage-based pricing is straightforward with proper state management

**Key Takeaways:**

1. **Managed services accelerate shipping** ‚Äì Clerk + Cloudinary + Stripe = weeks saved
2. **Type safety end-to-end** ‚Äì Prisma + Zod + TypeScript catch bugs before production
3. **Server actions are perfect for SaaS** ‚Äì Co-located logic with automatic revalidation
4. **Webhook-driven architecture** scales ‚Äì Async event handling keeps the app responsive

This architecture transfers directly to any AI-powered SaaS: document processing, video editing, audio enhancement, or content generation. The patterns here‚Äîtyped server actions, webhook-driven sync, and declarative transformations‚Äîare production-ready and battle-tested.

---
title: 'CarePulse Lite: Streamlined Patient Scheduling'
publishedAt: '2024-06-07'
summary: 'Building a healthcare intake and appointment workflow with Next.js, Appwrite, and Twilio notifications.'
category: 'Case Study'
githubURL: 'https://github.com/adrianhajdin/care-pulse'
image: '/medias/mdx-content/carepulse-lite.webp'
---

# CarePulse Lite

CarePulse Lite is a healthcare intake and scheduling experience that leans on Next.js 14, Appwrite, and Twilio to help clinics onboard patients quickly while keeping admins in the loop. The project lives in [the CarePulse Lite GitHub repository](https://github.com/adrianhajdin/care-pulse) and demonstrates how far you can go with server actions, typed forms, and composable UI primitives.

## Why this project / motivation

Healthcare teams often juggle manual spreadsheets, insecure emails, and endless phone calls just to book appointments. We wanted to explore how a modern frontend stack could remove that friction: let patients self-serve, capture the data we need for compliance, and push updates to staff without building a custom backend from scratch. Appwrite delivers the database and auth layer, while Twilio carries the final "your appointment is confirmed" SMS.

## What it does / overview

The flow starts on a welcoming landing screen that asks for only the essentials. Once a patient enters their name, email, and phone, we provision an Appwrite user and route them into a guided registration wizard. From there they can schedule appointments, upload identity documents, and consent to privacy policies. Administrators get a responsive dashboard where they can review every request, confirm or cancel slots, and keep tabs on pipeline metrics.

Key highlights:

- **Multi-step patient onboarding** powered by <InlineCode>react-hook-form</InlineCode> and Zod validation.
- **Appwrite-backed storage** for patient profiles, appointment documents, and admin stats.
- **Server actions** that keep business logic close to the UI layer while revalidating admin pages instantly.
- **Twilio SMS notifications** so patients hear back the moment an appointment is scheduled or cancelled.
- **Sentry instrumentation** wired through the project‚Äôs configs to observe performance in production.

## How it works (architecture, APIs, or hooks)

The Next.js App Router organizes the experience into three pillars:

1. **Patient intake** (<InlineCode>app/page.tsx</InlineCode>) renders the <InlineCode>PatientForm</InlineCode> client component. It triggers the <InlineCode>createUser</InlineCode> server action, which wraps Appwrite‚Äôs Users API and gracefully handles duplicate email or phone collisions before redirecting to registration.„ÄêF:components/forms/PatientForm.tsx‚Ä†L1-L77„Äë„ÄêF:lib/actions/patient.actions.ts‚Ä†L1-L67„Äë
2. **Profile registration** (<InlineCode>app/patients/[userId]/register/page.tsx</InlineCode>) hydrates with Appwrite data on the server. If the user already has a patient document, we skip ahead to appointment booking; otherwise, we render the <InlineCode>RegisterForm</InlineCode> with prefilled data and upload handling backed by Appwrite storage.„ÄêF:app/patients/[userId]/register/page.tsx‚Ä†L1-L36„Äë„ÄêF:components/forms/RegisterForm.tsx‚Ä†L1-L115„Äë
3. **Scheduling & admin operations** use shared form components. Patients submit pending requests through <InlineCode>createAppointment</InlineCode>, while admins can confirm or cancel via <InlineCode>updateAppointment</InlineCode>. Both actions live in the <InlineCode>lib/actions/appointment.actions.ts</InlineCode> module and revalidate the dashboard path to keep TanStack Table views fresh.„ÄêF:components/forms/AppointmentForm.tsx‚Ä†L1-L118„Äë„ÄêF:lib/actions/appointment.actions.ts‚Ä†L1-L120„Äë

Data modeling and messaging are centralized in Appwrite and Twilio configuration helpers. The Appwrite client is initialized once, exposing Databases and Users services to every action.„ÄêF:lib/appwrite.config.ts‚Ä†L1-L20„Äë When admins change an appointment, we format the schedule and send an SMS using the Twilio client that is lazily instantiated only if credentials exist, protecting local development from misconfigured environments.„ÄêF:lib/actions/appointment.actions.ts‚Ä†L80-L157„Äë„ÄêF:lib/twilio.config.ts‚Ä†L1-L40„Äë

<Callout icon='üí°'>
  Remember to populate the Appwrite and Twilio environment variables listed in
  the project README before running <InlineCode>npm run dev</InlineCode>.
  Without them, server actions will throw authorization errors or silently skip
  SMS delivery.{' '}
</Callout>

## Code snippets (use <InlineCode> for small code and fenced tsx or ts for examples</InlineCode>)

We rely on focused server actions to keep form submissions clean. Here‚Äôs the appointment creator in its entirety:

```ts
// lib/actions/appointment.actions.ts
export const createAppointment = async (
appointment:
CreateAppointmentParam=() => {
const cleanAppointment = {
userId: appointment.userId,
client: appointment.patient,
schedule: appointment.schedule,
reason: appointment.reason,
status: appointment.status,
note: appointment.note || "",
company: appointment.company || "Unknown",
};

const newAppointment = await databases.createDocument(
DATABASE_ID!,
APPOINTMENT_COLLECTION_ID!,
ID.unique(),
cleanAppointment
);

revalidatePath("/admin");
return parseStringify(newAppointment);
};

```

On the frontend, the appointment form chooses the correct action based on intent, sharing the same Zod schema for creation, scheduling, and cancellation:

```tsx
// components/forms/AppointmentForm.tsx
const onSubmit = async (values: z.infer<typeof AppointmentFormValidation>) => {
  const status =
    type === 'schedule'
      ? 'scheduled'
      : type === 'cancel'
        ? 'cancelled'
        : 'pending'

  if (type === 'create' && patientId) {
    const appointment = {
      userId,
      patient: patientId,
      schedule: new Date(values.schedule),
      reason: values.reason!,
      status: status as Status,
      note: values.note || '',
    }

    const newAppointment = await createAppointment(appointment)
    if (newAppointment) {
      form.reset()
      router.push(
        `/patients/${userId}/new-appointment/success?appointmentId=${newAppointment.$id}`
      )
    }
  } else {
    await updateAppointment({
      userId,
      appointmentId: appointment?.$id!,
      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
      appointment: {
        schedule: new Date(values.schedule),
        status: status as Status,
        cancellationReason: values.cancellationReason,
      },
      type,
    })
  }
}
```

## Demo / Media if applicable (use `<RoundedVideo>` or `<Image>` components)

<Image
  src='/assets/images/onboarding-img.png'
  alt='CarePulse Lite onboarding screen'
/>
<Image src='/assets/images/appointment-img.png' alt='Appointment booking UI' />

## Conclusion (reflective summary of developer benefits or learnings)

CarePulse Lite showcases how Next.js 14 server actions, Appwrite‚Äôs managed backend, and Twilio SMS can orchestrate a polished healthcare experience without spinning up a bespoke API layer. The modular form components, reusable validation schemas, and instant admin revalidation create a blueprint you can adapt to any intake-driven workflow‚Äîwhether it‚Äôs for clinics, consultations, or service bookings.

---
title: 'Immersive 3D Portfolio'
publishedAt: '2024-05-30'
summary: 'Building an interactive developer portfolio with React, React Three Fiber, and a cinematic contact flow.'
category: 'Lab'
githubURL: 'https://github.com/salahbm/3d-web-portfolio'
image: '/medias/mdx-content/3d-web-portfolio.webp'
---

# 3D Web Portfolio Experience

Creating a memorable personal site is hard when most portfolios look the same. This project leans into WebGL, audio, and playful interactions to tell a developer story without feeling like yet another template.

## Why this project / motivation

I wanted a way to introduce myself that felt more like a miniature game than a static landing page. The goal was to blend narrative, motion, and content: a 3D hero island that you can spin, project cards that feel alive, and a contact form guarded by a curious fox animation. React Three Fiber and Tailwind CSS let me ship that idea without leaving the React ecosystem.

## What it does / overview

The site runs on Vite + React with React Router for multi-page navigation. A 3D home scene invites visitors to drag the island, watch planes loop overhead, and discover CTAs as the camera reveals different sides. Additional routes cover bio, work history, and highlighted projects sourced from a shared data module. The experience closes with a contact page that pipes messages through EmailJS while a looping audio track sets the tone.

## How it works (architecture, APIs, or hooks)

- **Routing shell** ‚Äì <InlineCode>App.jsx</InlineCode> wraps a shared <InlineCode>Navbar</InlineCode> and <InlineCode>Footer</InlineCode> around nested routes using <InlineCode>react-router-dom</InlineCode>. Home lives at the root while <InlineCode>/about</InlineCode>, <InlineCode>/projects</InlineCode>, <InlineCode>/experience</InlineCode>, and <InlineCode>/contact</InlineCode> load their own sections inside the shell.„ÄêF:src/App.jsx‚Ä†L1-L35„Äë
- **Hero Canvas** ‚Äì <InlineCode>Home.jsx</InlineCode> renders two stacked <InlineCode>Canvas</InlineCode> instances from React Three Fiber. Each loads GLB assets with Drei‚Äôs <InlineCode>useGLTF</InlineCode>, lights the scene, and orchestrates state-driven interactions (stage hints, plane/rocket animations, swap-able islands). Touch and wheel input slide between hero and secondary canvases.„ÄêF:src/pages/Home.jsx‚Ä†L1-L210„Äë
- **Model controllers** ‚Äì Components like <InlineCode>Island</InlineCode>, <InlineCode>FlyingPlane</InlineCode>, and <InlineCode>Fox</InlineCode> encapsulate each GLB. They hook into <InlineCode>useFrame</InlineCode> for per-frame updates, <InlineCode>useAnimations</InlineCode> for baked clips, and manual event listeners for drag-to-rotate behavior.„ÄêF:src/models/Island.jsx‚Ä†L12-L137„Äë„ÄêF:src/models/FlyingPlane.jsx‚Ä†L13-L47„Äë
- **Data-driven sections** ‚Äì Project tiles pull from <InlineCode>src/constant/skills.js</InlineCode>, making it painless to update copy, badges, and outbound links in one place.„ÄêF:src/pages/Projects.jsx‚Ä†L1-L95„Äë„ÄêF:src/constant/skills.js‚Ä†L1-L120„Äë
- **Contact workflow** ‚Äì The contact page keeps form state locally, pipes submissions to EmailJS with environment keys, and surfaces toast-style feedback via a reusable <InlineCode>useAlert</InlineCode> hook. Animation state toggles the fox mascot between idle, walk, and hit clips as users interact.„ÄêF:src/pages/Contacts.jsx‚Ä†L1-L147„Äë„ÄêF:src/hook/useAlert.js‚Ä†L1-L11„Äë
- **Audio affordance** ‚Äì The <InlineCode>Navbar</InlineCode> instantiates a looping Sakura soundtrack using the Web Audio API and exposes play/pause through a dedicated <InlineCode>Music</InlineCode> control, keeping the atmosphere consistent across routes.„ÄêF:src/components/Navbar.jsx‚Ä†L1-L49„Äë

<Callout icon='üí°'>
  GLB components were generated with the pmndrs <InlineCode>gltfjsx</InlineCode>{' '}
  tool, so every model ships as a typed JSX wrapper. That keeps transforms and
  material references co-located with React state, which is much easier to
  maintain than raw Three.js loader
  code.„ÄêF:src/models/Island.jsx‚Ä†L1-L15„Äë„ÄêF:src/models/FlyingPlane.jsx‚Ä†L1-L20„Äë
</Callout>

## Code snippets (use <InlineCode> for small code and fenced tsx or ts for examples</InlineCode>)

Here‚Äôs the heart of the landing scene: a responsive canvas that swaps entire islands and updates UI copy as you rotate.

```tsx
// src/pages/Home.jsx
const Home = () => {
  const [isRotating, setIsRotating] = useState(false)
  const [currentStage, setCurrentStage] = useState(1)
  const [swapIslands, setSwapIslands] = useState('foxIsland')

  const [isIslandPosition, isIslandScale, isIslandRotation] =
    adjustIslandForScreenSize()

  return (
    <section
      className='relative h-screen w-full overflow-hidden'
      ref={containerRef}
    >
      <div className='absolute left-0 top-24 z-10 flex items-center justify-center'>
        {currentStage && <HomeInfo currentStage={currentStage} />}
      </div>

      <Canvas
        className={`h-screen w-full bg-transparent ${isRotating ? 'cursor-grabbing' : 'cursor-grab'}`}
      >
        <Suspense fallback={<Loader />}>
          <directionalLight position={[1, 1, 1]} intensity={2} />
          {swapIslands === 'foxIsland' ? (
            <Island
              position={isIslandPosition}
              scale={isIslandScale}
              rotation={isIslandRotation}
              isRotating={isRotating}
              setIsRotating={setIsRotating}
              setCurrentStage={setCurrentStage}
            />
          ) : (
            <Island2 /* alternate environment */ />
          )}
          <FlyingPlane isRotating={isRotating} />
        </Suspense>
      </Canvas>
    </section>
  )
}
```

Dragging the island works because <InlineCode>Island.jsx</InlineCode> listens for pointer events directly on the underlying WebGL canvas and applies a damped rotation:

```tsx
// src/models/Island.jsx
const Island = ({ isRotating, setIsRotating, setCurrentStage, ...props }) => {
  const islandRef = useRef()
  const lastX = useRef(0)
  const rotationSpeed = useRef(0)
  const dampingFactor = 0.95

  const handlePointerDown = (event) => {
    setIsRotating(true)
    lastX.current = event.touches ? event.touches[0].clientX : event.clientX
  }

  const handlePointerMove = (event) => {
    if (isRotating) {
      const clientX = event.touches ? event.touches[0].clientX : event.clientX
      const delta = (clientX - lastX.current) / viewport.width
      islandRef.current.rotation.y += delta * 0.01 * Math.PI
      rotationSpeed.current = delta * 0.01 * Math.PI
      lastX.current = clientX
    }
  }

  useFrame(() => {
    if (!isRotating) {
      rotationSpeed.current *= dampingFactor
      if (Math.abs(rotationSpeed.current) < 0.001) rotationSpeed.current = 0
      islandRef.current.rotation.y += rotationSpeed.current
    }
  })

  return (
    <a.group ref={islandRef} {...props}>
      {/* meshes */}
    </a.group>
  )
}
```

## Demo / Media if applicable (use `<RoundedVideo>` or `<Image>` components)

<RoundedVideo
  src='/medias/mdx-content/3d-web-portfolio-demo.mp4'
  caption='Rotating the hero island reveals different CTAs.'
/>

## Conclusion (reflective summary of developer benefits or learnings)

This build reaffirmed that WebGL doesn‚Äôt have to be intimidating if you stay inside React and lean on tooling like Drei and <InlineCode>gltfjsx</InlineCode>. By pairing a traditional router with 3D scenes, I could keep content maintainable while shipping something unforgettable. Feel free to explore or fork the repo on GitHub to spin it into your own story.
